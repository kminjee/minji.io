---
layout: post
title: (React) 모던 리액트 Deep Dive 2장
categories: Frontend
published: true
---

<br>

## 목차

1. [JSX란](#JSX란)
2. [가상 DOM과 리액트 파이버](#가상-DOM과-리액트-파이버)
3. [클래스형 컴포넌트와 함수형 컴포넌트](#클래스형-컴포넌트와-함수형-컴포넌트)
4. [렌더링은 어떻게 일어나는가](#렌더링은-어떻게-일어나는가)
5. [컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션](#컴포넌트와-함수의-무거운-연산을-기억해-두는-메모이제이션)

<br>

## JSX란

XML과 유사한 내장형 구문으로, 자바스크립트 표준 코드가 아닌 페이스북이 임의로 만든 새로운 문법이다. JSX는 반드시 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 자바스크립트 코드로 변환된다. JSX의 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는데 초점을 두고 있다. 트랜스파일이라는 과정을 거쳐 자바스크립트(ECMAScript)가 이해할 수 있는 코드로 변경하는 것이 목표다.

JSX는 HTML, XML 외에도 다른 구문으로도 확장될 수 있게 고려돼있고, 최대한 구문을 간결하고 쉽게 작성될 수 있게 설계됐다.

- **JSX 정의** <br>
  JSX는 기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings 네 가지 컴포넌트를 기반으로 구성되어있다.

  - JSXElement : 가장 기본 요소로 HTML의 요소(element)와 비슷한 역할이다. HTML 구문 이외에 사용자가 컴포넌트를 만들어 사용할 떄는 반드시 대문자로 시작하는 컴포넌트를 만들어야 사용 가능하다. 이유는 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트명을 구분 짓기 위해서이다.
  - JSXStrings : 자바스크립트와는 한가지 중요한 차이점이 있는데 `\`는 자바스크립트에서 특수문자를 처리할 때 사용된다. (`\`를 표현하고자 한다면 `\\`로 이스케이프 해야 한다.)

- **JSX가 자바스크립트에서 변환되는 법** <br>
  자바스크트에서 JSX가 변환되는 방식을 알기 전에, 리액트에서 JSX를 변환하는 `@babel/plugin-transform-react-jsx` 플러그인을 알아야 한다. 이 플러그인은 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환된다.

  ```javascript
  const ComponentA = <A required={true}>Hello World</A>;
  const ComponentB = <>Hello World</>;
  const ComponentC = (
    <div>
      <span>hello world</span>
    </div>
  );

  // 위 코드를 @babel-plugin-transform-react-jsx로 변환한 결과
  ("use strict");

  var ComponentA = React.createElement(A, { required: true }, "Hello World");

  var ComponentB = React.createElement(React.Fragment, null, "Hello world");
  var ComponentC = React.createElement(
    "div",
    null,
    React.CreatElement("span", null, "hello world")
  );
  ```

<br>

## 가상 DOM과 리액트 파이버

### 1. DOM과 브라우저 렌더링 과정

먼저 DOM(Document Object Model)이란, 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

우선 브라우저가 웹사이트 접근 요청을 받고 화면을 어떻게 그리는지 순서를 정리해보면,

1. 브라우저가 요청 받은 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)을 만들고 중간에 CSS 파일이 있으면 CSS 파일도 다운로드한다.
3. 브라우저가 방금 만든 DOM 노드를 순회하면서 사용자 눈에 보이는 노드만 방문해서 작업을 한다. (\*`display: none` 같은 화면에 보이지 않는 요소는 작업하지 않는다는 것)
4. 눈에 보이는 노드를 대상으로 CSSOM 정보를 찾고 스타일 정보를 만든 DOM 노드에 적용한다. 여기서 CSS를 적용하는 과정은 두 가지로 나뉜다.
   - 레이아웃 : 각 노드가 화면 어느 좌표에 나타나야 하는지 계산하는 과정
   - 페인팅 : 레이아웃 단계를 지나 노드에 색과 같은 유효한 모습을 그리는 과정

<br>

### 2. 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링 하는 과정은 복잡하고 많은 비용이 든다. 요즘 앱은 렌더링된 이후 정보를 보여주면서 사용자의 인터랙션을 통해 다양한 정보도 노출한다. 따라서 렌더링 완료 이후에 사용자의 인터랙션으로 웹페이지가 변경되는 것도 고려해야 한다.

예를 들어 특정 요소의 노출 여부나 사이즈의 변경점이 있을 때 요소의 위치와 크기를 재계산하는데 이 경우에는 레이아웃이 일어나고 리페인팅이 발생하기 때문에 더 많은 비용이 든다. DOM 변경이 일어나는 요소에 자식 요소가 많을 떄는 하위 자식도 함꼐 변경돼야 하기 때문에 더 많은 비용을 브라우저와 사용자가 지불한다.

SPA(Signle Page Application)은 페이지 깜빡임 없이 자연스럽게 웹페이지 사용이 가능하지만 그만큼 DOM을 관리하는 과정에 부담 비용이 커진다. 사용자의 인터랙션에 따라 DOM의 모든 변경사항을 추적하는 것은 번거로운 일이다.

이 문제점을 해결하기 위해 탄생한 것이 바로 <u>가상 DOM</u>이다. 리액트(react-dom)이 관리하는 가상의 DOM을 말하며 웹페이지가 표시해야할 DOM을 우선 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다.

<br>

### 3. 가상 DOM을 위한 아키텍쳐, 리액트 파이버

- **리액트 파이버란?** <br>
  리액트 파이버(React Fiber)는 리액트에서 관리하는 평범한 자바스크립트 객체이다. 가상 DOM과 렌더링 과정 최적화를 가능하게 해준다.

  파이버는 파이버 재조정자(fiber reconciler)가 관리하는데 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고, 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청한다. 여기서 재조정은 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)을 말한다.

  파이버는 이런 일을 할 수 있는데 중요한 것은 '**비동기**'로 일어난다. 1. 작업을 작은 단위로 분할하고 쪼갠 뒤 우선 순위를 매긴다. 2. 이런 작업을 일시 중지하고 나중에 다시 시작할 수도 있다. 3. 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.

  파이버는 하나의 작업 단위로 구성되어 있다. 리액트는 이런 작업 단위를 하나씩 처리하고 `finishedWork()`라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.

  파이버가 리액트 요소와 유사하다고 생각할 수 있지만 중요한 차이점은 리액트는 '렌더링이 발생할 떄마다 새롭게 생성'되고, 파이버는 '컴포넌트가 최초로 마운트되는 시점에 생성되어 이후 가급적 재사용'된다.

  성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점에 실행된다. <br>
  리액트 파이버의 가상 DOM이 자바스크립트 객체로 관리되고 있어서 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다. 변수에 UI 관련 값을 보관하고 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것이 바로 리액트다.

<br>

- **리액트 파이버 트리** <br>
  파이버 트리는 리액트 내부에서 두 개가 존재한다.

  - 현재 모습을 담은 파이버 트리
  - 작업 중인 상태를 나타내는 `workInProgress` 트리

  리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 `workInProgress` 트리를 현재 트리로 변경한다. 이 기술을 더블 버퍼링이라고 한다. 더블 버퍼링을 간단하게 설명하면 그래픽 분야에서 사용하는 용어로, 사용자에게 완성하다 만 그림을 보여주지 않기 위해 보이지 않는 곳에서 다음 그림을 미리 그린 다음 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 말한다.

  리액트에서도 다 그리지 못한 모습을 노출하지 않기 위해 더블 버퍼링 기법을 사용하는데 따라서 트리가 두 개 존재하며 더블 버퍼링은 커밋 단계에서 수행된다.

  만약 setState 등으로 업데이트가 발생한다면, 앞서 만든 current 트리가 존재하고 setState 업데이트 요청을 받아 workInProgress 트리를 다시 빌드한다. 빌드 과정은 트리를 만드는 과정과 동일하다. 여기서 위에 언급한 <u>'파이버는 '컴포넌트가 최초로 마운트되는 시점에 생성되어 이후 가급적 재사용' 된다.'</u> 라는 것이 기존 파이버에서 업데이트 된 props를 받아 파이버 내부에서 처리하는 것이다. 기존 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트 한다.

<br>

### 4. 파이버와 가상 DOM

파이버는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있으며 리액트 아키텍쳐 내부에서 비동기로 이뤄진다. <br>
하지만 실제 브라우저 구조인 DOM에 업데이트 할 때는 동기적으로 일어나야 한다. 또 처리하는 작업이 많아서 화면에 불완전하게 표시될 수 있는 가능성이 많기 때문에 이 작업은 가상(메모리상)에서 먼저 수행하고 최종 결과물만 실제 브라우저 DOM에 적용한다.

만약 개발자가 DOM을 수동으로 하나하나 변경해야 한다면 어떤 값이 바뀌었는지, 값에 따라 어떤 값이 변경됐는지 등 파악하기 매우 어려웠을 것이다. 이 어려움을 리액트 내부의 파이버와 재조정자가 내부적인 알고리즘을 통해 관리해줌으로써 대규모 프로젝트도 효율적으로 유지보수하고 관리할 수 있는 것이다.

가상 DOM과 리액트 핵심은 값으로 UI를 표현하는 것이다. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이 흐름을 효율적으로 관리하기 위한 매커니즘이 리액트의 핵심이다.

<br>

## 클래스형 컴포넌트와 함수형 컴포넌트

함수형 컴포넌트는 리액트 v0.14 부터 만들어진 역사 깊은 컴포넌트 선언 방식이다. 당시에는 단순히 어떠한 요소를 정적으로 렌더링하는 것이 목적이였고, 함수형 컴포넌트가 각광받기 시작한 것은 v16.8 에서 훅(hook)이 소개된 이후이다.

### 1. 클래스형 컴포넌트

리액트 v16.8 미만으로 작성된 코드는 클래스형 컴포넌트가 대다수이다.

- **constructor()** <br>
  생성자 함수라고 하며, 컴포넌트가 초기화되는 시점에 호출된다. 컴포넌트의 state를 초기화할 수 있다. <br>
  생성자 함수 안에서 선언하는 `super()`는 상속받은 상위 컴포넌트인 React.Component의 생성자 함수를 먼저 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.

- **props** <br>
  특정 속성을 전달하는 용도이다.

- **state** <br>
  컴포넌트 내부에서 관리하는 값으로 항상 객체여야만 한다. 이 값에 변화가 생길 떄마다 리렌더링이 발생한다.

- **method** <br>
  렌더링 함수 내부에서 사용되고, DOM에서 발생하는 이벤트와 함께 사용된다. 메서드를 만드는 방식에는 여러가지가 있는데 아래 코드처럼 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법을 지양하는 것이 좋다. 매번 렌더링이 일어날 때마다 새로운 함수를 생성해서 할당하게 되어 최적화에 좋지 않다.

  ```javascript
  <button onClick={() => this.handleClick()}>증가</button>
  ```

<br>

- **클래스형 컴포넌트의 생명주기 메서드** <br>
  생명주기 메서드가 실행되는 시점 세 가지

  1. mount : 컴포넌트가 생성(mounting)되는 시점
  2. update : 이미 생성된 컴포넌트의 내용이 변경(update)되는 시점
  3. unmount : 컴포넌트가 더 이상 존재하지 않는 시점

  <br>

  생명주기 메서드 
  - render <br>
      render 역시 생명주기 메서드 중 하나다. UI를 렌더링하기 위해 쓰이며 필수 값이다. render는 항상 순수해야하며 부수 효과가 없어야 한다. render 내부에 state를 직접 업데이트 하는 this.setState를 호출해선 안 되고, state를 변경하는 일은 클래스형 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야 한다.

  - componentDidMount() <br>
      컴포넌트가 마운트되고 준비되는 즉시 실행된다. 이 함수 내부에서 setState로 값을 변경할 수 있으며 변경되는 즉시 리렌더링이 되는데 브라우저가 실제로 UI를 업데이트 하기 전에 실행되기 때문에 사용자가 변경을 눈치채지 못하게 한다.

  - componentDidUpdate() <br>
      업데이트가 일어난 이후 바로 실행된다. 이 함수 안에서 setState를 사용할 때는 적절한 조건문으로 감싸서 사용해야 한다. 그렇지 않으면 setState가 계속해서 호출될 수 있다.

      ```javascript
      componentDidUpdate(prevProps: Props, prevState: State) {
        if (this.props.userName !== prevProps.userName) {
          this.fetchData(this.props.userName);
        }
      }
      ```
  
  <br>
  
  - componentWillUnmount() <br>
      컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다. 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다. 
  
  - shouldComponentUpdate() <br>
      state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용하면 된다. state 변경으로 인한 리렌더링은 자연스러운 일이기 때문에 메서드를 사용할 떄는 특정한 성능 최적화 상황에만 고려하는 것이 좋다.
      
      ```javascript
      shouldComponentUpdate(nextProps: Props, nextState: State) {

        // ex) props의 title이 같거나 state의 input이 같은 경우에는 컴포넌트를 업데이트 하지 않는다. 
        return this.props.title !== nextProps.title || this.state.input !== nextState.input
      }
      ```
  
  <br>

  - getDerivedStateFromError() <br>
      에러 상황에서 실행되는 메서드이고 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드다. 렌더링 과정에서 호출하는 메서드기 때문에 부수효과를 발생시키면 안 된다. `console.log` 도 부수효과에 해당된다. 

  <br>

- **클래스형 컴포넌트의 한계** <br>
  함수형 컴포넌트에 훅을 도입한 새로운 패러다임을 만든 이유에 대해 클래스형 컴포넌트의 여러가지 문제점을 추측해볼 수 있다.

  - state가 어떤 식의 흐름으로 변경되어 렌더링이 일어나거나 일어나지 않는지 데이터의 흐름을 추적하기 어렵다.
  - 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트가 많아지거나 props가 많아져 wrapper hell(래퍼 지옥)에 빠질 위험이 커지면서 내부 로직의 재사용이 어려워진다.
  - 컴포넌트 내부에 로직이 많아질수록 내부에서 처리는 데이터 흐름이 복잡해지고 컴포넌트 크기가 커진다.
  - 번들 크기를 줄이는데 어려움이 있어 최적화하기 어렵다. 컴포넌트를 빌드했을 떄 메서드 이름이 최소화 되지도 않고 사용하지 않는 메서드가 번들에 그대로 포함돼 최적화하기에 불리하다.

<br>

### 2. 함수형 컴포넌트
리액트 v16.8 이전에는 단순히 무상태 컴포넌트를 구현하기 위한 하나의 수단이였지만 이후에 훅이 등장하면서 개발자들에게 각광받고 있다. 클래스형에서는 state를 객체로 사용해야 했지만, 함수형에서는 state는 객체가 아닌 원시값으로 관리되어 훨씬 사용하기 편해졌다. 

<br>

### 3. 함수형 컴포넌트 vs 클래스형 컴포넌트

- **생명주기 메서드의 부재** <br>
  함수형에서는 생명주기 메서드가 존재하지 않는다. props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스형은 render 메서드가 있는 React.Component를 상속 받아 구현하는 JavaScript 클래스이다.
  
  함수형에 존재하는 `useEffect` 훅으로 생명주기 메서드인 `componentDidMount`, `componentDidUpdate`, `componentWillUnMount`를 비슷하게 구현할 수 있지만 말 그대로 비슷할 뿐 똑같은 것이 아니다. 

- **함수형 컴포넌트와 렌더링된 값** <br>
  함수형은 렌더링이 일어날 떄마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. 반면 클래스형은 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다. 
  
<br>

## 렌더링은 어떻게 일어나는가
브라우저에서의 렌더링은 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미한다. <br>
리액트에서 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

### 1. 리액트의 렌더링이란?
리액트의 애플리케이션 트리 안에 있는 모든 컴포넌트들이 자신이 가지고 있는 props와 state의 값을 기반으로 UI와 DOM 결과를 어떻게 브라우저에게 제공할 것인지를 계산하는 과정을 의미한다. 

<br>

### 2. 리액트의 렌더링이 일어나는 이유
1. 브라우저에게 정보를 제공하기 위한 최초 렌더링을 수행
2. 최초 렌더링 이후 발생하는 모든 리렌더링
    - useState() 두 번쨰 요소인 setter가 실행될 때
    - useReducer()의 두 번째 요소인 dispatch가 실행될 때
    - 컴포넌트의 key props가 변경될 때 <br>
        > *리액트의 배열에서 key가 필요한 이유* <br>
        > *리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에 동일한 요소를 식별하는 값이다. 리렌더링이 발생하면 current 트리와 workInProgress 트리 사이에서 어떤 컴포넌트가 변경됐는지 구별할 때 쓰인다.*
    - props가 변경될 때 <br>
    - 부모 컴포넌트에서 렌더링될 때 <br>
      > *부모 컴포넌트가 렌더링되거나, 부모로부터 전달받는 props가 변경되면 자식 컴포넌트도 리렌더링 된다.

<br>

### 3. 렌더와 커밋
리액트의 렌더링은 '렌더 단계'와 '커밋 단계' 두 단계로 분리되어 실행된다.
- 렌더 단계 (Render Phase) <br>
  컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업. 렌더링 프로세스에서 컴포넌트를 실행하고 결과와 이전 가상 DOM을 비교해서 변경이 필요한 컴포넌트를 체크하는 단계다. 크게 세가지로 `type`, `props`, `key` 가 있다.

- 커밋 단계 (Commit Phase) <br>
  렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 작업. 이 단계가 끝나야 브라우저의 렌더링이 발생된다.

리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 렌더 단계를 수행했으나 변경 사항이 없다면 커밋 단계는 생략될 수 있다. 커밋 단계가 생략되면 DOM 업데이트는 일어나지 않는다. 

두가지 과정의 렌더링은 항상 동기식으로 작동됐다. 렌더링 과정이 길수록 성능 저하로 이이어졌다. 렌더링이 비동기 방식으로 이뤄진다면 컴포넌트 변경에 순서가 뒤섞이게 되고 사용자에게 혼란을 줄 수있다. 하지만 반대로 A의 컴포넌트 작업이 무거워서 B컴포넌트의 작업을 먼저 렌더링해서 보여줄 수 있다는 이점도 있다. 

리액트 v18.0 에서 이처럼 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링인 <u>**동시성 렌더링**</u>이 도입됐다.

<br>

## 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
나는 최근까지도 프로젝트를 개발하면서 메모이제이션에 고민을 갖고 있었다. 메모이제이션 사용을 어디까지 해야하는지에 대해서 말이다. 책에는 내가 그동안 생각해왔던 질문들이 모두 적혀있었다.

메모이제이션 기법은 언제 사용하는 것이 좋을까? <br>
무거운 연산의 기준은 무엇일까? <br>
모든 컴포넌트에 메모이제이션을 해도 되지 않을까? <br>
렌더링 비용과 메모이제이션 비용 중 어떤게 더 비싼걸까? <br>
...

이런 메모이제이션 최적화는 리액트 커뮤니티에서도 오랜 논쟁 중 하나이다. '메모이제이션을 섣불리 해서는 안 된다'와 '무조건 메모이제이션은 필요하다' 두 주장으로 나뉜다. 

<br>

### 1. 필요한 곳에만 메모이제이션을 추가하자
메모이제이션도 어디까지나 비용이 드는 작업으로 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 결과물을 저장해 두었다가 다시 꺼내와야하는 작업 두 가지 비용이 있다. 따라서 과연 메모이제이션의 비용이 리렌더링 비용보다 저렴하다고 할 수 있을까?

개발자에게 선택권이 있다는 것은 메모이제이션이 모든 문제를 해결할 수 있는 것은 아니라는 사실을 방증한다.

<br>

### 2. 렌더링 과정의 비용은 비싸므로 모두 메모이제이션해 버리자
두 주장에 공통점은 일부 컴포넌트에서는 메모이제이션이 성능에 도움 된다는 것이다.
만약 애플리케이션 규모가 크고 컴포넌트의 복잡성이 증가하고 개발자도 많은 상황이라면, 실무에 임하는 모든 개발자들이 최적화나 성능 향상에 시간이 많지 않다고 생각하면 전자의 기조를 유지하기 힘들 것이다.

우선 모든 곳에 memo를 감싸고 만약 렌더링 비용이 적은 컴포넌트의 memo 사용에 대한 비용을 생각했을 때, 지불해야 하는 비용은 props에 대한 얕은 비교 발생에 대한 비용이다. (리액트는 기본적인 알고리즘으로 이전 결과물을 무조건 저장해두기 때문이다.)

memo를 하지 않았을 때의 발생할 수 있는 문제의 비용이 더 크다.
- 렌더링 발생 비용
- 컴포넌트 내부의 복잡한 로직 재실행
- 위 두 가지로 인한 자식 컴포넌트의 영향
- 이전 트리와 신규 트리 비교

최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용해 최적화를 하는 것이 좋다.

