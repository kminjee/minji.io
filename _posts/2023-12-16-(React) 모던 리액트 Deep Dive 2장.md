---
layout: post
title: (React) 모던 리액트 Deep Dive 2장
categories: Frontend
published: true
---

<br>

## 목차

1. [JSX란?](#JSX란?)
2. [가상 DOM과 리액트 파이버](#가상-DOM과-리액트-파이버)

<br>

## JSX란?

XML과 유사한 내장형 구문으로, 자바스크립트 표준 코드가 아닌 페이스북이 임의로 만든 새로운 문법이다. JSX는 반드시 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 자바스크립트 코드로 변환된다. JSX의 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는데 초점을 두고 있다. 트랜스파일이라는 과정을 거쳐 자바스크립트(ECMAScript)가 이해할 수 있는 코드로 변경하는 것이 목표다.

JSX는 HTML, XML 외에도 다른 구문으로도 확장될 수 있게 고려돼있고, 최대한 구문을 간결하고 쉽게 작성될 수 있게 설계됐다.

- **JSX 정의** <br>
  JSX는 기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings 네 가지 컴포넌트를 기반으로 구성되어있다.

  - JSXElement : 가장 기본 요소로 HTML의 요소(element)와 비슷한 역할이다. HTML 구문 이외에 사용자가 컴포넌트를 만들어 사용할 떄는 반드시 대문자로 시작하는 컴포넌트를 만들어야 사용 가능하다. 이유는 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트명을 구분 짓기 위해서이다.
  - JSXStrings : 자바스크립트와는 한가지 중요한 차이점이 있는데 `\`는 자바스크립트에서 특수문자를 처리할 때 사용된다. (`\`를 표현하고자 한다면 `\\`로 이스케이프 해야 한다.)

- **JSX가 자바스크립트에서 변환되는 법** <br>
  자바스크트에서 JSX가 변환되는 방식을 알기 전에, 리액트에서 JSX를 변환하는 `@babel/plugin-transform-react-jsx` 플러그인을 알아야 한다. 이 플러그인은 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환된다.

  ```javascript
  const ComponentA = <A required={true}>Hello World</A>;
  const ComponentB = <>Hello World</>;
  const ComponentC = (
    <div>
      <span>hello world</span>
    </div>
  );

  // 위 코드를 @babel-plugin-transform-react-jsx로 변환한 결과
  ("use strict");

  var ComponentA = React.createElement(A, { required: true }, "Hello World");

  var ComponentB = React.createElement(React.Fragment, null, "Hello world");
  var ComponentC = React.createElement(
    "div",
    null,
    React.CreatElement("span", null, "hello world")
  );
  ```

<br>

## 가상 DOM과 리액트 파이버

### 1. DOM과 브라우저 렌더링 과정

먼저 DOM(Document Object Model)이란, 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

우선 브라우저가 웹사이트 접근 요청을 받고 화면을 어떻게 그리는지 순서를 정리해보면,

1. 브라우저가 요청 받은 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)을 만들고 중간에 CSS 파일이 있으면 CSS 파일도 다운로드한다.
3. 브라우저가 방금 만든 DOM 노드를 순회하면서 사용자 눈에 보이는 노드만 방문해서 작업을 한다. (\*`display: none` 같은 화면에 보이지 않는 요소는 작업하지 않는다는 것)
4. 눈에 보이는 노드를 대상으로 CSSOM 정보를 찾고 스타일 정보를 만든 DOM 노드에 적용한다. 여기서 CSS를 적용하는 과정은 두 가지로 나뉜다.
   - 레이아웃 : 각 노드가 화면 어느 좌표에 나타나야 하는지 계산하는 과정
   - 페인팅 : 레이아웃 단계를 지나 노드에 색과 같은 유효한 모습을 그리는 과정

<br>

### 2. 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링 하는 과정은 복잡하고 많은 비용이 든다. 요즘 앱은 렌더링된 이후 정보를 보여주면서 사용자의 인터랙션을 통해 다양한 정보도 노출한다. 따라서 렌더링 완료 이후에 사용자의 인터랙션으로 웹페이지가 변경되는 것도 고려해야 한다.

예를 들어 특정 요소의 노출 여부나 사이즈의 변경점이 있을 때 요소의 위치와 크기를 재계산하는데 이 경우에는 레이아웃이 일어나고 리페인팅이 발생하기 때문에 더 많은 비용이 든다. DOM 변경이 일어나는 요소에 자식 요소가 많을 떄는 하위 자식도 함꼐 변경돼야 하기 때문에 더 많은 비용을 브라우저와 사용자가 지불한다.

SPA(Signle Page Application)은 페이지 깜빡임 없이 자연스럽게 웹페이지 사용이 가능하지만 그만큼 DOM을 관리하는 과정에 부담 비용이 커진다. 사용자의 인터랙션에 따라 DOM의 모든 변경사항을 추적하는 것은 번거로운 일이다.

이 문제점을 해결하기 위해 탄생한 것이 바로 <u>가상 DOM</u>이다. 리액트(react-dom)이 관리하는 가상의 DOM을 말하며 웹페이지가 표시해야할 DOM을 우선 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다.

<br>

### 3. 가상 DOM을 위한 아키텍쳐, 리액트 파이버

- **리액트 파이버란?** <br>
  리액트 파이버(React Fiber)는 리액트에서 관리하는 평범한 자바스크립트 객체이다. 가상 DOM과 렌더링 과정 최적화를 가능하게 해준다.

  파이버는 파이버 재조정자(fiber reconciler)가 관리하는데 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고, 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청한다. 여기서 재조정은 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)을 말한다.

  파이버는 이런 일을 할 수 있는데 중요한 것은 '**비동기**'로 일어난다. 1. 작업을 작은 단위로 분할하고 쪼갠 뒤 우선 순위를 매긴다. 2. 이런 작업을 일시 중지하고 나중에 다시 시작할 수도 있다. 3. 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.

  파이버는 하나의 작업 단위로 구성되어 있다. 리액트는 이런 작업 단위를 하나씩 처리하고 `finishedWork()`라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.

  파이버가 리액트 요소와 유사하다고 생각할 수 있지만 중요한 차이점은 리액트는 '렌더링이 발생할 떄마다 새롭게 생성'되고, 파이버는 '컴포넌트가 최초로 마운트되는 시점에 생성되어 이후 가급적 재사용'된다.

  성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점에 실행된다. <br>
  리액트 파이버의 가상 DOM이 자바스크립트 객체로 관리되고 있어서 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다. 변수에 UI 관련 값을 보관하고 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것이 바로 리액트다.

<br>

- **리액트 파이버 트리** <br>
  파이버 트리는 리액트 내부에서 두 개가 존재한다.

  - 현재 모습을 담은 파이버 트리
  - 작업 중인 상태를 나타내는 `workInProgress` 트리

  리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 `workInProgress` 트리를 현재 트리로 변경한다. 이 기술을 더블 버퍼링이라고 한다. 더블 버퍼링을 간단하게 설명하면 그래픽 분야에서 사용하는 용어로, 사용자에게 완성하다 만 그림을 보여주지 않기 위해 보이지 않는 곳에서 다음 그림을 미리 그린 다음 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 말한다.

  리액트에서도 다 그리지 못한 모습을 노출하지 않기 위해 더블 버퍼링 기법을 사용하는데 따라서 트리가 두 개 존재하며 더블 버퍼링은 커밋 단계에서 수행된다.

  만약 setState 등으로 업데이트가 발생한다면, 앞서 만든 current 트리가 존재하고 setState 업데이트 요청을 받아 workInProgress 트리를 다시 빌드한다. 빌드 과정은 트리를 만드는 과정과 동일하다. 여기서 위에 언급한 <u>'파이버는 '컴포넌트가 최초로 마운트되는 시점에 생성되어 이후 가급적 재사용' 된다.'</u> 라는 것이 기존 파이버에서 업데이트 된 props를 받아 파이버 내부에서 처리하는 것이다. 기존 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트 한다.

<br>

### 4. 파이버와 가상 DOM

파이버는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있으며 리액트 아키텍쳐 내부에서 비동기로 이뤄진다. <br>
하지만 실제 브라우저 구조인 DOM에 업데이트 할 때는 동기적으로 일어나야 한다. 또 처리하는 작업이 많아서 화면에 불완전하게 표시될 수 있는 가능성이 많기 때문에 이 작업은 가상(메모리상)에서 먼저 수행하고 최종 결과물만 실제 브라우저 DOM에 적용한다.

만약 개발자가 DOM을 수동으로 하나하나 변경해야 한다면 어떤 값이 바뀌었는지, 값에 따라 어떤 값이 변경됐는지 등 파악하기 매우 어려웠을 것이다. 이 어려움을 리액트 내부의 파이버와 재조정자가 내부적인 알고리즘을 통해 관리해줌으로써 대규모 프로젝트도 효율적으로 유지보수하고 관리할 수 있는 것이다.

가상 DOM과 리액트 핵심은 값으로 UI를 표현하는 것이다. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이 흐름을 효율적으로 관리하기 위한 매커니즘이 리액트의 핵심이다.
