---
layout: post
title: (React) 모던 리액트 Deep Dive 1장
categories: Frontend
published: true
---

<br>

## 목차

1. [리액트의 역사](#리액트의-역사)
2. [리액트를 선택하는 이유](#리액트를-선택하는-이유)
3. [리액트의 다양한 라이브러리](#리액트의-다양한-라이브러리)

<br>

## 리액트의 역사

2000년대의 웹 생태계는 LAMP(Linux, Apache, MySQL, PHP) 스택이 주를 이뤘다. 서버에서 만든 HTML 페이지를 수동적으로 보여주던 프론트엔드의 역할이 2010년대부터 변하기 시작했는데, 자바스크립트를 더 편리하게 사용하기 위한 jQuery의 인기와 함께 로컬 스토리지, 웹소켓, 캔버스, SVG, 지오로케이션 등 다양한 기능들이 브라우저에서 지원이 가능해지고 자바스크립트의 DOM 수정, Ajax를 활용한 서버 통신까지 가능해졌다.

이때 페이스북은 전세계가 이용하는 소셜 네트워크 서비스로 자리 잡으면서 많은 이용자로 인해 성능 역시 중요했다. 그러나 실시간성이 강조된 기능들에는 로딩시간이 길거나 화면 전체가 깜빡이는 등 느리게 작동하는 것처럼 보일 수 밖에 없었다. 이후 BoltJS라는 프레임워크를 만들어 페이스북을 다시 개발하였고 BoltJS 프레임워크를 개선하기 위해 나온 아이디어 중 하나가 함수형을 지향하는 Fblot(Functional Bolt)이다. 이것이 리액트의 시초라고 한다.

JSconf US 2013에서 리액트가 처음 공개되었지만 대다수가 호의적이지 않았지만서도 리액트를 도입하는 사람들이 생겨나고 외부 개발자들의 아이디어와 함께 커뮤니티도 형성되면서 빛을 보았다.

신기한 것은 v0.14.7 바로 다음 버전이 v15.0.0 이다. 그리고 v16.8.0에서 hook(훅)이 나오면서 리액트는 제대로 눈에 띄기 시작했다.

<br>

## 리액트를 선택하는 이유

2011년 처음 선보인 리액트는 2018년을 기점으로 jQuery(제이쿼리)를 무너뜨렸으며 2023년 현재까지도 많이 사용하고 있으며 기세는 유지될 것으로 보인다. 전자정부 표준 프레임워크로 리액트가 채택됐다는 것은 안정성이 확보됐다는 의미이기도 하다.

1. 명시적인 상태변경 <br>
   데이터의 흐름이 한쪽으로만 흐르는 단방향 바인딩만 지원한다. 양방향 바인딩 같은 경우는 프로젝트 규모가 커진다면 그만큼 복잡해지기 때문에 상태 변화를 파악하기 어렵다. 따라서 리액트에서 상태가 변화했다면 명시적으로 일으킨 함수만 찾으면 되기 때문에 간단하고 유연하다.

2. 강력한 커뮤니티와 메타 <br>
   리액트는 단순히 UI를 위한 라이브러리로만 작동하는데 제한을 두고 그 외의 모든 것에는 자유롭다. 그래서 개발자들은 리액트를 기반으로 한 다양한 것들을 시도하였고 커뮤니티가 형셩될 수 있었다. 또 리액트 핵심 개발을 메타가 지원함으로써 꾸준히 발전하고 성장할 수 있었다.

<br>

## 리액트의 다양한 라이브러리

- 상태관리

  1. Redux
  2. Zustand
  3. Recoil
  4. Jotai

- 서버 사이드 렌더링

  1. Next.js
  2. Remix
  3. Hydrogen

- 폼
  1. React Hook Form
  2. React Final Form
  3. Formik

<br>

## 리액트 개발에 필요한 자바스크립트 필수 지식

### 1. 동등 비교

리액트에서 가삼 DOM과 실제 DOM의 비교, 컴포넌트가 렌더링을 판단하는 방법, 변수 또는 함수 메모이제이션 등 모든 작업들이 자바스크립트의 동등 비교를 기반으로 한다.

- **값을 저장하는 방식의 차이** <br>
  자바스크립트의 원시 타입과 객체 타입은 값을 저장하는 방식에 차이가 있다. <br>
  원시는 불변 형태의 값으로 저장되며 값은 변수 할당 시점에 메모리 영역을 차지하고 저장한다. <br>
  객체는 프로퍼티를 추가, 수정, 삭제가 가능하기 때문에 변경 가능한 형태로 저장되고 값을 복사할 때도 참조를 전달한다.

- **Object.is** <br>
  두 개의 인수를 받아 두 인수가 동일한지 확인하고 반환하는 메서드이다. === 비교와 동일하게 타입이 다르면 false를 반환한다.

리액트에서는 Object.is를 기반으로 한 `ShallowEqual` 함수를 만들어 동등비교를 한다. Object.is로 먼저 비교를 한 다음 Object.is에서 수행수 없는 비교는 객체의 첫 번째 깊이에 존재하는 값만 비교한다.

```javascript
Object.is({ hello: "world" }, { hello: "world" }); // 참조가 다르므로 비교 불가능

shallowEqual({ hello: "world" }, { hello: "world" }); // 1 depth 까지 비교 가능

shallowEqual({ hello: "world" }, { hello: { world: "hi" } }); // 2 depth 비교 불가능
```

객체의 첫 번째 깊이만 비교하는 이유는 리액트에서 사용하는 JSX props는 객체이고 일차적으로 비교하면 되기 때문이다.

<br>

### 2. 함수

- **일급 객체** <br>
  자바스크립트에서 함수는 일급객체다. 일급객체란 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 말한다. 다른 함수의 매개변수가 될 수도 있고, 반환값도 될 수 있고, 변수에 할당도 가능하다.

- **화살표 함수** <br>
  ES6에 추가된 함수 생성 방식으로 function 키워드 대신 `=>` 화살표를 활용하여 함수를 만든다. <br>
  화살표 함수와 일반 함수의 차이점은 this 바인딩이다. <br>
  클래스형 컴포넌트에서 일반 함수와 화살표 함수에 this를 참조했을 떄 일반 함수에서 this는 undefined, 화살표 함수에서는 클래스의 인스턴스를 가리킨다. this를 사용해야하는 클래스형 컴포넌트에서는 주의가 필요하다.

- **즉시 실행 함수와 고차 함수** <br>
  즉시 실행 함수는 함수를 정의하고 그 즉시 실행되며 단 한번만 호출된다. 재사용되지 않는 함수고 단 한번만 실행되고 끝난다면 즉시 실행 함수를 사용하는 것도 좋을 것 같다. <br>
  고차 함수는 함수를 인수로 받거나 새로운 함수로 결과를 반환시킬 수 있다.

<br>

### 3. 함수를 만들 때 주의해야 할 사항

- **함수의 부수효과를 최대한 줄일 것** <br>
  함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것으로 비순수 함수라고 한다. <br>
  반대로 순수함수는 부수 효과가 없고, 언제 어떤 상황에서든 동일한 인수를 받아 동일한 결과를 반환하는 것을 말한다.

  그런데 개발하는 과정에서 부수 효과는 피할 수 없는 요소이기도 하다. 컴포넌트 내부에 API를 호출하면 외부에 영향이 끼치므로 부수 효과가 되고, console.log 역시 콘솔 창에 영향을 끼치므로 부수 효과가 되는 등 여러 경우가 있다. 리액트에서도 `useEffect`는 부수 효과를 처리하므로 작동을 최소화하는 것이 좋다.

  함수의 실행 결과를 최대한 예측 가능하게 설계하여 유지보수하는데 도움되는 것이 좋다.

- **함수를 작게 만들 것** <br>
  'Do One Thing and Do It Well'. 함수는 하나의 일을, 그 하나만 잘하면 된다라고 유닉스 선구자인 더글러스 매킬로이가 말했다. <br>
  함수의 코드가 길어질수록 무슨 일이 일어나는지 추적이 어렵다. 따라서 하나의 함수 안에서 너무 많은 일을 하지 않게 한다면 함수의 목적인 재사용성을 높일 수 있다.

<br>

### 3. 클래스
