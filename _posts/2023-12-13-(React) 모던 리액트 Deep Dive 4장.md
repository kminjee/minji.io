---
layout: post
title: (React) 모던 리액트 Deep Dive 4장
categories: Frontend
published: true
---

<br>

## 목차

1. [서버 사이드 렌더링이란](#서버-사이드-렌더링이란)
2. [서버 사이드 렌더링을 위한 리액트 API](#서버-사이드-렌더링을-위한-리액트-API)

<br>

## 서버 사이드 렌더링이란

### 1. 싱글 페이지 애플리케이션

싱글 페이지 애플리케이션 (Single Page Application: SPA) 이란, 렌더링과 라우팅에 필요한 대부분의 기능을 브라우저의 자바스크립트에 의존하는 방식이다. <br>
최초에 서버에서 최소한의 데이터를 불러오고, 이후에는 이미 가지고 있는 자바스크립트 리소스와 브라우저 API를 기반으로 모든 작동이 이뤄진다. 최초 로딩에 자바스크립트 리소스가 커지는 단점이 있지만 한번 로딩 이후에는 서버에 필요한 리소스를 받아올 일이 적어 사용자 경험에 좋다는 장점이 있다.

- **MPA(Multi Page Application)와 SPA의 작동 비교** <br>
  **MPA**

  - 과거 서버 사이드에서 작동하던 전통적인 방식으로 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱하는 작업
  - 페이지가 전환될 때 흰 화면을 보이는 부자연스러운 모습을 보일 수 있음

  **SPA**

  - 최초에 모든 리소스를 다운 받고 페이지 전환 시에 추가 리소스를 다운받는 시간이 필요하지 않음
  - 페이지를 전환할 때 필요한 일부 영역만 다시 그리므로 매끄러운 UI를 보여줄 수 있음

- **싱글 페이지 렌더링 방식의 유행과 JAM 스택 등장** <br>
  과거 PHP, JSP를 기반으로 한 웹 애플리케이션은 대부분 서버 사이드에서 이뤄졌다. 당시만 해도 자바스크립트는 사용자에게 추가적인 경험을 주기 위한 보조 수단이였다. 하지만 점점 사용자 기기 성능과 인터넷 속도 발전으로 자바스크립트에서 할 수 있는 일이 다양해졌고 웹 페이지의 모든 영역(페이지의 렌더링에서부터 사용자의 인터넥션에 이르기까지)을 담당하고 이렇게 모두 아우를 수 있는 방식인 'SPA'가 인기를 얻게 됐다.

  기존 웹 개발은 LAMP(Linux, Apache, MySQL, PHP/Python)으로 구성되어 있었는데 웹 애플리케이션 기능이 다양해지고 사용자가 늘어나면 서버 확장이 필요했는데 클라우드 개념이 부족한 당시에는 서버 확장하는 것이 번거로웠다.

  그래서 등장한 것이 'JAM(Javascript, API, Markup)' 스택이다. <br>
  프런트엔드는 자바스크립트와 마크업을 미리 빌드해 두고 정적으로 사용자에게 제공하면 이후 작동은 모두 사용자의 클라이언트에서 실행되므로 서버 확장성 문제에 좀 더 자유로워졌다. 여기서 JAM 스택의 인기와 Node.js의 고도화로 MEAN(MongoDB, Express.js, React, Node.js) 스택처럼 아예 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끌었다.

- **새로운 패러다임의 웹서비스를 향한 요구** <br>
  자바스립트 파싱을 위해 CPU를 소비하는 시간이 눈에 띄게 증가하였고, 그만큼 자바스크립트에서 처리해야 하는 코드의 양도 증가했다. 사용자의 기기와 인터넷 속도 등 웹 전반을 이루는 환경이 개선되었음에도 실제 느끼는 로딩 속도는 5년 전이나 지금이나 크게 차이가 없거나 오히려 느리다.

### 2. 서버 사이드 렌더링

서버 사이드 렌더링 (Server Side Rendering) 은 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식이다. <br>
위에서 말한 웹페이지가 점점 느려지는 상황을 SPA에서의 한계를 찾았고, 이를 개선하고자 기존의 웹 개발 방식이 다시 떠오르고 있다.

SPA와 SSR의 차이는 <u>웹페이지 렌더링의 책임을 어디에 두느냐</u>이다.

- **서버 사이드 렌더링의 장점**

  - 최초 페이지 진입이 비교적 빠르다 <br>
    화면 렌더링이 HTTP 요청에 의존적이거나 렌더링해야할 HTML의 크기가 커진다면 상대적으로 SSR이 빠를 수 있다. 하지만 리소스를 확보하기 어렵다면 오히려 SPA보다 느릴 수 있다.

  - 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다 <br>
    검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있으므로 SEO에 대응하기 매우 용이하다.

  - 누적 레이아웃 이동이 적다 <br>
    사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 수정되어 화면이 덜컥거리는 것 같은 사용자 경험을 말하며, SSR에서는 요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 이런 문제에서 비교적 자유롭다.

  - 사용자의 디바이스 성능에 비교적 자유롭다 <br>
    자바스크립트 리소스 실행은 사용자의 디바이스에서만 실행되므로 절대적으로 사용자의 디바이스 성능에 의존적이다. 이런 부담을 서버에 나눔으로써 사용자 디바이스 성능으로부터 좀 더 자유로워질 수 있다.

  - 보안에 좀 더 안전하다 <br>
    API 호출과 인증 같이 사용자에게 노출되면 안 되는 민감한 작업은 서버에서 수행하고 그 결과만 브라우저에 제공하여 보안 위험을 피할 수 있다.

- **서버 사이드 렌더링의 단점**

  - 소스코드를 작성할 때 서버도 고려해야 한다 <br>
    소스코드 전반에 걸쳐 서버 환경에 대한 고려가 필요한데, 외부에 의존하는 라이브러리의 경우 라이브러리가 서버에 대한 고려가 없다면 클라이언트에서만 실행될 수 있도록 처리해야 하며 클라이언트에서만 실행되는 코드가 많아질수록 SSR의 장점을 잃는다.

  - 적절한 서버가 구축되어 있어야 한다 <br>
    사용자의 요청에 따라 적절히 대응할 수 있는 물리적인 가용량 확보, 예상치 못한 장애 상황에 대한 복구 전략 등이 필요하다.

  - 서비스 지연에 따른 문제 <br>
    서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기까지 그 어떤 정보도 제공할 수 없다.

### 3. SPA와 SSR을 모두 알아야 하는 이유

웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지, 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요하다. 그에 따라 SPA가 더 효율적일 수도 있으므로 서버 사이드 렌더링 역시 만능이 아니다.

현대의 서버 사이드 렌더링에는 SPA의 장점과 SSR의 장점을 모두 취한 방식으로 작동된다. <br>
최초 웹사이트 진입 시에는 SSR 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 SPA처럼 작동한다. `Next.js`,`Remix` 등 각광받는 서버 사이드 렌더링 프레임워크가 이런 방식으로 작동해 사용자에게 더 나은 웹사이트 경험을 준다.

## 서버 사이드 렌더링을 위한 리액트 API

### 1. renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 리액트 컴포넌트를 기준으로 빠르게 브라우저가 렌더링할수 있는 HTML을 제공하는데 목적
- useEffect 같은 훅, 이벤트 헨들러는 결과물에 포함되지 않음
- `div#root` 속성에 `data-reactroot` 가 존재하며, 리액트 컴포넌트 루트 엘리먼트가 무엇인지 식별하는 역할

### 2. renderToStaticMarkup

- `data-reactroot` 와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않음
- 리액트에서만 사용하는 속성이 없으며 결과물인 HTML 크기를 약간이라도 줄일 수 있는 장점이 있음
- useEffect와 같은 브라우저 API를 실행할 수 없음
- 블로그 글이나 약관 정보 같은 브라우저 액션이 없는 정적 내용에 유용

### 3. renderToNodeStream

- 큰 데이터를 다룰 때 데이터를 청크(chunk, 작은 단위)로 분할해 조금씩 가져오는 방식
- renderToString으로 생성해야 하는 HTML의 크기가 매우 큰 경우에 청크 단위로 분리해 순차적으로 처리할 수 있음
- 1번과 2번 API는 브라우저에서도 실행할 수 있지만, 해당 API는 브라우저에서 사용하는 것이 완전히 불가능
- Node.js의 ReadableStream의 결과물이며 utf-8로 인코딩된 바이트 스트림이며 Node.js 환경에서만 사용 가능
- ReadableStream 자체는 브라우저에도 사용할 수 있는 객체이지만 만드는 과정이 브라우저에서 불가능하게 구현되어 있음

### 4. renderToStaticNodeStream

- hydrate를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용

### 5. hydrate

- 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행
- HTML에는 renderToString 등으로 렌더링된 정적인 HTML 정보가 반드시 담겨있어야 함
- 번외
  - render : hydrate와 비슷한 브라우저에서만 사용되는 메서드로 컴포넌트와 HTML 요소를 인수로 받아 두 정보를 바탕으로 HTML의 요소에 해당 컴포넌트를 렌더링하고 이벤트 헨들러를 붙이는 작업까지 모두 한 번에 수행

### 6. 서버 사이드 렌더링 프로젝트 구조

- index.tsx : 서버로부터 받은 HTML을 hydrate를 통해 완성된 웹 애플리케이션으로 만드는 것
- App.tsx : 사용자가 만드는 리액트 애플리케이션의 시작점
- index.html : 서버 사이드 렌더링을 수행할 때 기본이 되는 HTML 템플릿
- server.ts : 서버에서 동작하는 파일로, 사용자의 요청 주소에 따라 어떤 리소스를 내려줄지 결정하는 역할과 리액트 트리를 만드는 역할도 담당
- webpack.config.js : 보통 create-react-app 내부에서 웹팩 설정을 모두 대신 해줌
