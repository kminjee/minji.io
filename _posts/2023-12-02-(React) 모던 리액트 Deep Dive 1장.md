---
layout: post
title: (React) 모던 리액트 Deep Dive 1장
categories: Frontend
published: true
---

<br>

## 목차

1. [리액트의 역사](#리액트의-역사)
2. [리액트를 선택하는 이유](#리액트를-선택하는-이유)
3. [리액트의 다양한 라이브러리](#리액트의-다양한-라이브러리)
4. [리액트 개발에 필요한 자바스크립트 필수 지식](#리액트-개발에-필요한-자바스크립트-필수-지식)

<br>

## 리액트의 역사

2000년대의 웹 생태계는 LAMP(Linux, Apache, MySQL, PHP) 스택이 주를 이뤘다. 서버에서 만든 HTML 페이지를 수동적으로 보여주던 프론트엔드의 역할이 2010년대부터 변하기 시작했는데, 자바스크립트를 더 편리하게 사용하기 위한 jQuery의 인기와 함께 로컬 스토리지, 웹소켓, 캔버스, SVG, 지오로케이션 등 다양한 기능들이 브라우저에서 지원이 가능해지고 자바스크립트의 DOM 수정, Ajax를 활용한 서버 통신까지 가능해졌다.

이때 페이스북은 전세계가 이용하는 소셜 네트워크 서비스로 자리 잡으면서 많은 이용자로 인해 성능 역시 중요했다. 그러나 실시간성이 강조된 기능들에는 로딩시간이 길거나 화면 전체가 깜빡이는 등 느리게 작동하는 것처럼 보일 수 밖에 없었다. 이후 BoltJS라는 프레임워크를 만들어 페이스북을 다시 개발하였고 BoltJS 프레임워크를 개선하기 위해 나온 아이디어 중 하나가 함수형을 지향하는 Fblot(Functional Bolt)이다. 이것이 리액트의 시초라고 한다.

JSconf US 2013에서 리액트가 처음 공개되었지만 대다수가 호의적이지 않았지만서도 리액트를 도입하는 사람들이 생겨나고 외부 개발자들의 아이디어와 함께 커뮤니티도 형성되면서 빛을 보았다.

신기한 것은 v0.14.7 바로 다음 버전이 v15.0.0 이다. 그리고 v16.8.0에서 hook(훅)이 나오면서 리액트는 제대로 눈에 띄기 시작했다.

<br>

## 리액트를 선택하는 이유

2011년 처음 선보인 리액트는 2018년을 기점으로 jQuery(제이쿼리)를 무너뜨렸으며 2023년 현재까지도 많이 사용하고 있으며 기세는 유지될 것으로 보인다. 전자정부 표준 프레임워크로 리액트가 채택됐다는 것은 안정성이 확보됐다는 의미이기도 하다.

1. 명시적인 상태변경 <br>
   데이터의 흐름이 한쪽으로만 흐르는 단방향 바인딩만 지원한다. 양방향 바인딩 같은 경우는 프로젝트 규모가 커진다면 그만큼 복잡해지기 때문에 상태 변화를 파악하기 어렵다. 따라서 리액트에서 상태가 변화했다면 명시적으로 일으킨 함수만 찾으면 되기 때문에 간단하고 유연하다.

2. 강력한 커뮤니티와 메타 <br>
   리액트는 단순히 UI를 위한 라이브러리로만 작동하는데 제한을 두고 그 외의 모든 것에는 자유롭다. 그래서 개발자들은 리액트를 기반으로 한 다양한 것들을 시도하였고 커뮤니티가 형셩될 수 있었다. 또 리액트 핵심 개발을 메타가 지원함으로써 꾸준히 발전하고 성장할 수 있었다.

<br>

## 리액트의 다양한 라이브러리

- 상태관리

  1. Redux
  2. Zustand
  3. Recoil
  4. Jotai

- 서버 사이드 렌더링

  1. Next.js
  2. Remix
  3. Hydrogen

- 폼
  1. React Hook Form
  2. React Final Form
  3. Formik

<br>

## 리액트 개발에 필요한 자바스크립트 필수 지식

### 1. 동등 비교

리액트에서 가삼 DOM과 실제 DOM의 비교, 컴포넌트가 렌더링을 판단하는 방법, 변수 또는 함수 메모이제이션 등 모든 작업들이 자바스크립트의 동등 비교를 기반으로 한다.

- **값을 저장하는 방식의 차이** <br>
  자바스크립트의 원시 타입과 객체 타입은 값을 저장하는 방식에 차이가 있다. <br>
  원시는 불변 형태의 값으로 저장되며 값은 변수 할당 시점에 메모리 영역을 차지하고 저장한다. <br>
  객체는 프로퍼티를 추가, 수정, 삭제가 가능하기 때문에 변경 가능한 형태로 저장되고 값을 복사할 때도 참조를 전달한다.

- **Object.is** <br>
  두 개의 인수를 받아 두 인수가 동일한지 확인하고 반환하는 메서드이다. === 비교와 동일하게 타입이 다르면 false를 반환한다.

리액트에서는 Object.is를 기반으로 한 `ShallowEqual` 함수를 만들어 동등비교를 한다. Object.is로 먼저 비교를 한 다음 Object.is에서 수행수 없는 비교는 객체의 첫 번째 깊이에 존재하는 값만 비교한다.

```javascript
Object.is({ hello: "world" }, { hello: "world" }); // 참조가 다르므로 비교 불가능

shallowEqual({ hello: "world" }, { hello: "world" }); // 1 depth 까지 비교 가능

shallowEqual({ hello: "world" }, { hello: { world: "hi" } }); // 2 depth 비교 불가능
```

객체의 첫 번째 깊이만 비교하는 이유는 리액트에서 사용하는 JSX props는 객체이고 일차적으로 비교하면 되기 때문이다.

<br>

### 2. 함수

- **일급 객체** <br>
  자바스크립트에서 함수는 일급객체다. 일급객체란 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 말한다. 다른 함수의 매개변수가 될 수도 있고, 반환값도 될 수 있고, 변수에 할당도 가능하다.

- **화살표 함수** <br>
  ES6에 추가된 함수 생성 방식으로 function 키워드 대신 `=>` 화살표를 활용하여 함수를 만든다. <br>
  화살표 함수와 일반 함수의 차이점은 this 바인딩이다. <br>
  클래스형 컴포넌트에서 일반 함수와 화살표 함수에 this를 참조했을 떄 일반 함수에서 this는 undefined, 화살표 함수에서는 클래스의 인스턴스를 가리킨다. this를 사용해야하는 클래스형 컴포넌트에서는 주의가 필요하다.

- **즉시 실행 함수와 고차 함수** <br>
  즉시 실행 함수는 함수를 정의하고 그 즉시 실행되며 단 한번만 호출된다. 재사용되지 않는 함수고 단 한번만 실행되고 끝난다면 즉시 실행 함수를 사용하는 것도 좋을 것 같다. <br>
  고차 함수는 함수를 인수로 받거나 새로운 함수로 결과를 반환시킬 수 있다.

<br>

### 3. 함수를 만들 때 주의해야 할 사항

- **함수의 부수효과를 최대한 줄일 것** <br>
  함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것으로 비순수 함수라고 한다. <br>
  반대로 순수함수는 부수 효과가 없고, 언제 어떤 상황에서든 동일한 인수를 받아 동일한 결과를 반환하는 것을 말한다.

  그런데 개발하는 과정에서 부수 효과는 피할 수 없는 요소이기도 하다. 컴포넌트 내부에 API를 호출하면 외부에 영향이 끼치므로 부수 효과가 되고, console.log 역시 콘솔 창에 영향을 끼치므로 부수 효과가 되는 등 여러 경우가 있다. 리액트에서도 `useEffect`는 부수 효과를 처리하므로 작동을 최소화하는 것이 좋다.

  함수의 실행 결과를 최대한 예측 가능하게 설계하여 유지보수하는데 도움되는 것이 좋다.

- **함수를 작게 만들 것** <br>
  'Do One Thing and Do It Well'. 함수는 하나의 일을, 그 하나만 잘하면 된다라고 유닉스 선구자인 더글러스 매킬로이가 말했다. <br>
  함수의 코드가 길어질수록 무슨 일이 일어나는지 추적이 어렵다. 따라서 하나의 함수 안에서 너무 많은 일을 하지 않게 한다면 함수의 목적인 재사용성을 높일 수 있다.

<br>

### 4. 클래스
클래스란 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것으로 일종의 템플릿 같은 개념이다. 클래스 내부에는 여러가지 특징들이 있다.

- **constructor** <br>
   객체를 생성하는 데 사용하는 특수한 메서드이다. 단 하나만 존재하고 여러개를 사용하면 에러가 난다. <br>
   반대로 생성자에서 수행할 작업이 없다면 생략하는 것도 가능하다.

- **property** <br>
   클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값을 의미한다.

- **instance method** <br>
  클래스 내부에서 선언한 메서드이다. 이 인스턴스 메서드는 실제로 자바스크립트 프로토타입에 선언되어서 프로토타입 메서드라고도 부른다.
  ```javascript
  class Car() {
     constructor(name) {
        this.name = name;
     };

     log() {
        console.log(this.name);
     };
  };

  const myCar = new Car('자동차');
  myCar.log(); // 자동차
  ```
  위 예제에서 새로 생성한 myCar 객체에서 클래스에 선언된 log() 인스턴스 메서드에 접근할 수 있는 이유는 이야기했듯 프로토타입에 선언되었기 때문이다. <br>
  직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것을 프로토타입 체이닝이라고 한다. <br>
  모든 객체는 프로토타입을 가지고 있는데 특정 속성을 찾을 때 자기 자신부터 시작해서 프로토타입을 타고 최상위 객체인 Object까지 찾는다.
  
  비슷한 원리로 `toString()`이 객체 어디에서도 선언하지 않았지만 사용할 수 있는 이유가 프로토타입 체이닝을 거쳐 최상위 Object에 있는 `toString()`을 만나기 때문이다.

<br>

### 5. 클로저
함수형 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수형 컴포넌트의 대부분의 기술이 모두 클로저에 의존한다. 

- **스코프** <br>
  클로저를 이해하기 위해서는 변수의 유효 범위인 스코프(scope)를 알아야 한다. <br>
  전역 스코프는 전역 레벨에 선언하는 것으로 전역 스코프에서 선언된 변수는 어디서든 호출할 수 있다. <br>
  함수 스코프는 새로운 함수가 생성될때마다 새로운 스코프가 발생한다. 

리액트 함수형 컴포넌트의 훅에서 클로저의 원리를 사용하는 대표적인 것이 `useState` 이다.
```javascript
function Component() {
  const [state, setState] = useState()

  function handleClick() {
    setState(prev => prev + 1)
  }
}
```
useState 함수의 호출은 첫 줄에서 끝났는데, setState는 내부의 최신 값을 계속 업데이트 할 수 있는 이유는 클로저가 useState 안에서 활용됐기 때문이다. `useState(외부 함수)`가 반환한 `setState(내부 함수)`는 `useState(외부 함수)` 호출이 끝났음에도 선언된 환경을 기억하기 때문에 계속해서 state 값을 사용할 수 있는 것이다. 

<br>

### 6. 이벤트 루프와 비동기 통신의 이해
자바스크립트는 싱글 스레드에서 작동한다. 한 번에 하나의 작업만 동기 방식으로 처리한다는 것이다. <br>
동기는 직렬 방식으로 작업을 처리하는 것을 의미하고 요청이 시작된 이후에 무조건 응답을 받은 이후에야 다른 작업을 처리할 수 있다. 그 동안 다른 모든 작업은 대기 상태이다. 

먼저 프로세스란 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위를 말한다. 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것이다. 점차 복잡해진 소프트웨어의 발전으로 하나의 프로그램에 여러개의 작업을 수행할 필요가 생겼고, 더 작은 단위의 작업인 '스레드'의 탄생으로 하나의 프로세스에서 여러 개의 스레드를 만들 수 있고 스레드끼리 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있게 됐다. 이를 멀티 스레드라고 하는데 멀티 스레드의 단점은 내부적으로 처리가 복잡하다는 단점이 있다. 

자바스크립트의 모든 코드는 '동기식'으로 한 번에 하나씩 순차적으로 처리하는 'Run-to-completion'의 특징을 가지고 있다. 

- **이벤트 루프** <br>
  자바스크립트에서 비동기 함수를 선언할 때 async를 사용한다. 동기식으로 작동하는 자바스크립트에서 이런 비동기 코드 처리할 수 있는 방법을 알려면 '이벤트 루프'를 이해해야 한다.

  이벤트 루프는 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치이다. <br>
  자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아주는 스택을 '호출 스택'이라 하는데 호출 스택이 비어있는지 여부를 확인하는 것이 이벤트 루프이다. 
  
  이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야할 작업이 있는지 확인하고, 작업이 없다면 자바스크립트 엔진을 이용해 실행한다. 여기서 '코드를 실행하는 것'과 '호출 스택이 비어있는지 확인하는 것' 모두 단일 스레드에서 일어난다. 동시에 일어날 수 없고 한 스레드에서 순차적으로 일어난다는 것이다. 

  ```javascript
  function bar() {
    console.log('bar')
  }

  function baz() {
    console.log('baz')
  }

  function foo() {
    console.log('foo') 
    // setTimeout(bar(), 0)이 호출 스택에 들어간다.
    // setTimeout(bar(), 0)의 타이머 이벤트가 실행되며 태스크 큐로 들어가고 바로 스택에서 제거된다.
    setTimeout(bar(), 0)
    baz()
  }

  // `foo()`에 남은 것이 없어 호출 스택에서 제거되고 호출 스택이 비워지면 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인한다. 
  // 그리고 태스크 큐를 확인하여 setTimeout(bar(), 0)이 있는 것을 확인하고 bar()를 호출 스택에 들여보낸다. 
  foo() 
  ```
  위 코드에서 `setTimeout(bar(), 0)`이 정확히 0초 뒤에 실행된다는 걸 보장하지 못한다는 것을 알 수 있다. 여기서 태스크 큐는 '실행해야 할' 태스크의 집합이다. 이벤트 루프는 태스크 큐를 한 개 이상 가지고 있다. 자료 구조의 Queue가 아닌 set 형태이다. 이유는 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다. 태스크 큐에서 의미하는 '실행해야 할' 태스크는 비동기 함수의 콜백 함수나 이벤트 핸들러를 의미한다.

<br>

- **비동기 통신** <br>
  비동기 함수는 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 자바스크립트 코드 실행은 싱글 스레드에서 이뤄지지만 외부 Web API등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다. 

<br>

### 태스크 큐와 마이크로 태스크 큐
이벤트 루프는 하나의 마스크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와 다른 태스크를 처리한다. 대표적으로 `Promise`가 있다. 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 가져서 setTimeout과 setInterval이 Prmoise보다 늦게 실행된다. 마이크로 태스크 큐가 빌 때까지 기존 태스크 큐 실행이 뒤로 미뤄진다. 
